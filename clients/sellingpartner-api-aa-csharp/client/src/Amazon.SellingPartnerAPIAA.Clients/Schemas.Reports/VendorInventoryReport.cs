//----------------------
// <auto-generated>
//     Generated using the NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------


namespace Amazon.SellingPartnerAPIAA.Clients.Schemas.Reports.VendorInventory
{
    #pragma warning disable // Disable all warnings

    /// <summary>
    /// Describes the aggregated inventory metrics for all ASINs in the vendor's account.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class InventoryAggregate
    {
        /// <summary>
        /// The start date of the aggregated data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The end date of the aggregated data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset EndDate { get; set; }

        /// <summary>
        /// The out of stock rate on all products that are procurable. This is calculated by out of stock glance views on a procurable ASIN divided by the total glance views.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("procurableProductOutOfStockRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double ProcurableProductOutOfStockRate { get; set; }

        /// <summary>
        /// The percentage of time an ASIN is available to be shipped to the customer from a fulfillment center, versus the selection Amazon intended to carry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uft", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Uft { get; set; }

        /// <summary>
        /// The purchase order units received by Amazon in comparison to the purchase order units confirmed by the vendor. This is calculated as the received quantity divided by the confirmed quantity.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("receiveFillRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double ReceiveFillRate { get; set; }

        /// <summary>
        /// The number of units that were confirmed by the vendor, divided by the number of units Amazon asked for. This rate will be 1 if all units that were requested during this time window were confirmed. This rate can be larger than 1 if the vendor has confirmed a greater quantity of units than Amazon requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vendorConfirmationRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double VendorConfirmationRate { get; set; }

        /// <summary>
        /// Cost of the inventory that Amazon received from the vendor, minus the cost of the inventory that was returned to the vendor. The cost returned to the vendor takes into account any products that were returned due to damaged merchandise. This number can be negative if more cost was returned than received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("netReceivedInventoryCost", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount NetReceivedInventoryCost { get; set; } = new Amount();

        /// <summary>
        /// Units received from the vendor minus any units that were returned to the vendor. This number can be negative if more units were returned than received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("netReceivedInventoryUnits", Required = Newtonsoft.Json.Required.Always)]
        public int NetReceivedInventoryUnits { get; set; }

        /// <summary>
        /// Number of units contained in Amazon’s confirmed purchase orders that are not yet received by Amazon. This number can be negative if the vendor has shipped more units than Amazon has requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("openPurchaseOrderUnits", Required = Newtonsoft.Json.Required.Always)]
        public int OpenPurchaseOrderUnits { get; set; }

        /// <summary>
        /// Average number of days between the submission of each purchase order unit and the time of receipt in Amazon's fulfillment centers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("averageVendorLeadTimeDays", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double AverageVendorLeadTimeDays { get; set; }

        /// <summary>
        /// The number of units shipped (less customer returns), divided by the sum of the number of units held by Amazon at the beginning of this time window and the number of units received during this time window. This number could be negative if more units were returned than were shipped. This number can be greater than 1 if some inventory was sold while in transit between fulfillment centers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellThroughRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SellThroughRate { get; set; }

        /// <summary>
        /// The number of units that have been ordered (or pre-ordered) but have not yet shipped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unfilledCustomerOrderedUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnfilledCustomerOrderedUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is in a sellable condition on the last day of the selected time window. Backorders count as a negative cost, and can cause this value to be negative overall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellableOnHandInventoryCost", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount SellableOnHandInventoryCost { get; set; } = new Amount();

        /// <summary>
        /// The number of units in Amazon fulfillment centers that is in a sellable condition on the last day of the selected time window. Backorders count as negative units, and can cause this value to be negative overall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellableOnHandInventoryUnits", Required = Newtonsoft.Json.Required.Always)]
        public int SellableOnHandInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is in unsellable condition on the last day of the selected time window.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unsellableOnHandInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PositiveAmount UnsellableOnHandInventoryCost { get; set; }

        /// <summary>
        /// The number of units in Amazon fulfillment centers that are in unsellable condition on the last day of the selected time window.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unsellableOnHandInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnsellableOnHandInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is at least 90 days old, and is in a sellable condition on the last day of the selected time window. Backorders count as negative cost, and can cause this value to be negative overall. Inventory age is computed based on when the inventory was received by Amazon. 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aged90PlusDaysSellableInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amount Aged90PlusDaysSellableInventoryCost { get; set; }

        /// <summary>
        /// The number of units in Amazon fulfillment centers that is at least 90 days old, and is in a sellable condition on the last day of the selected time window. Backorders count as negative units, and can cause this value to be negative overall. Inventory age is computed based on when the inventory was received by Amazon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aged90PlusDaysSellableInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Aged90PlusDaysSellableInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the excess inventory on the last day of the selected time window based on forecasted demand. Note that the forecasted demand may have already included some amount of excess inventory that makes economic sense to hold. This is the amount of inventory beyond the forecasted demand.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unhealthyInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PositiveAmount UnhealthyInventoryCost { get; set; }

        /// <summary>
        /// The number of excess inventory units on the last day of the selected time window based on forecasted demand. Note that the forecasted demand may have already included some amount of excess inventory that makes economic sense to hold. This is the amount of inventory beyond the forecasted demand.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unhealthyInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnhealthyInventoryUnits { get; set; }



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static InventoryAggregate FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<InventoryAggregate>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// Describes ASIN-aggregated inventory metrics for the vendor's account.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class InventoryByAsin
    {
        /// <summary>
        /// The start date of the aggregated data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset StartDate { get; set; }

        /// <summary>
        /// The end date of the aggregated data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset EndDate { get; set; }

        /// <summary>
        /// The Amazon Standard Identification Number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("asin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Asin { get; set; }

        /// <summary>
        /// The number of units that were confirmed by the vendor, divided by the number of units Amazon asked for. This rate will be 1 if all units that were requested during this time window were confirmed. This rate can be larger than 1 if the vendor has confirmed a greater quantity of units than Amazon requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vendorConfirmationRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double VendorConfirmationRate { get; set; }

        /// <summary>
        /// Cost of the inventory that Amazon received from the vendor, minus the cost of the inventory that was returned to the vendor. The cost returned to the vendor takes into account any products that were returned due to damaged merchandise. This number can be negative if more cost was returned than received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("netReceivedInventoryCost", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount NetReceivedInventoryCost { get; set; } = new Amount();

        /// <summary>
        /// Units received from the vendor minus any units that were returned to the vendor. This number can be negative if more units were returned than received.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("netReceivedInventoryUnits", Required = Newtonsoft.Json.Required.Always)]
        public int NetReceivedInventoryUnits { get; set; }

        /// <summary>
        /// Number of units contained in Amazon’s confirmed purchase orders that are not yet received by Amazon. This number can be negative if the vendor has shipped more units than Amazon has requested.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("openPurchaseOrderUnits", Required = Newtonsoft.Json.Required.Always)]
        public int OpenPurchaseOrderUnits { get; set; }

        /// <summary>
        /// Average number of days between the submission of each purchase order unit and the time of receipt in Amazon's fulfillment centers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("averageVendorLeadTimeDays", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double AverageVendorLeadTimeDays { get; set; }

        /// <summary>
        /// The number of units shipped (less customer returns), divided by the sum of the number of units held by Amazon at the beginning of this time window and the number of units received during this time window. This number could be negative if more units were returned than were shipped. This number can be greater than 1 if some inventory was sold while in transit between fulfillment centers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellThroughRate", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double SellThroughRate { get; set; }

        /// <summary>
        /// Number of units that have been ordered (or pre-ordered) but have not yet shipped.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unfilledCustomerOrderedUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnfilledCustomerOrderedUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is in sellable condition on the last day of the selected time window. Backorders count as negative cost, and can cause this value to be negative overall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellableOnHandInventoryCost", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Amount SellableOnHandInventoryCost { get; set; } = new Amount();

        /// <summary>
        /// The number of units in Amazon fulfillment centers that is in sellable condition on the last day of the selected time window. Backorders count as negative units, and can cause this value to be negative overall.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellableOnHandInventoryUnits", Required = Newtonsoft.Json.Required.Always)]
        public int SellableOnHandInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is in unsellable condition on the last day of the selected time window.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unsellableOnHandInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PositiveAmount UnsellableOnHandInventoryCost { get; set; }

        /// <summary>
        /// The number of units in Amazon fulfillment centers that are in unsellable condition on the last day of the selected time window.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unsellableOnHandInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnsellableOnHandInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the inventory in Amazon fulfillment centers that is at least 90 days old, and is in a sellable condition on the last day of the selected time window. Backorders count as a negative cost, and can cause this value to be negative overall. Inventory age is computed based on when the inventory was received by Amazon. 
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aged90PlusDaysSellableInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amount Aged90PlusDaysSellableInventoryCost { get; set; }

        /// <summary>
        /// The number of units in Amazon fulfillment centers that is at least 90 days old, and is in a sellable condition on the last day of the selected time window. Backorders count as negative units, and can cause this value to be negative overall. Inventory age is computed based on when the inventory was received by Amazon.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("aged90PlusDaysSellableInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Aged90PlusDaysSellableInventoryUnits { get; set; }

        /// <summary>
        /// The cost of the excess inventory on the last day of the selected time window based on forecasted demand. Note that the forecasted demand may have already included some amount of excess inventory that makes economic sense to hold. This is the amount of inventory beyond the forecasted demand.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unhealthyInventoryCost", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PositiveAmount UnhealthyInventoryCost { get; set; }

        /// <summary>
        /// The number of excess inventory units on the last day of the selected time window based on forecasted demand. Note that the forecasted demand may have already included some amount of excess inventory that makes economic sense to hold. This is the amount of inventory beyond the forecasted demand.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("unhealthyInventoryUnits", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.Range(0, int.MaxValue)]
        public int UnhealthyInventoryUnits { get; set; }



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static InventoryByAsin FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<InventoryByAsin>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class Amount
    {
        /// <summary>
        /// The amount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        public double Amount1 { get; set; }

        /// <summary>
        /// Currency code of the amount. In ISO 4217 format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currencyCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CurrencyCode { get; set; }



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static Amount FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<Amount>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class PositiveAmount
    {
        /// <summary>
        /// The amount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Range(0D, double.MaxValue)]
        public double Amount { get; set; }

        /// <summary>
        /// Currency code of the amount. In ISO 4217 format.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("currencyCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CurrencyCode { get; set; }



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static PositiveAmount FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<PositiveAmount>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    /// <summary>
    /// This report shares inventory data of a vendor's items both at an aggregated level (across the vendor's entire catalog of items) and at a per-ASIN level. Data is available at different date range aggregation levels: DAY, WEEK, MONTH, QUARTER, YEAR. Requests can span multiple date range periods. For example, if the customer specified reportPeriod=WEEK and a dataStartTime and dataEndTime that are 3 weeks apart, the report would contain data for each of those 3 contiguous weeks.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class VendorInventoryReport
    {
        /// <summary>
        /// The report summary including a reporting date range, distributor view, selling program, and last updated date in the input.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportSpecification", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ReportSpecification ReportSpecification { get; set; } = new ReportSpecification();

        [Newtonsoft.Json.JsonProperty("inventoryAggregate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<InventoryAggregate> InventoryAggregate { get; set; } = new System.Collections.ObjectModel.Collection<InventoryAggregate>();

        [Newtonsoft.Json.JsonProperty("inventoryByAsin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<InventoryByAsin> InventoryByAsin { get; set; } = new System.Collections.ObjectModel.Collection<InventoryByAsin>();



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static VendorInventoryReport FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<VendorInventoryReport>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class ReportSpecification
    {
        /// <summary>
        /// The type of report.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ReportSpecificationReportType ReportType { get; set; }

        /// <summary>
        /// Report options specifying parameters such as reportPeriod, distributorView, and sellingProgram.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportOptions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ReportOptions ReportOptions { get; set; } = new ReportOptions();

        /// <summary>
        /// The date when the report was last updated. Follows the &lt;a href='https://developer-docs.amazon.com/sp-api/docs/iso-8601'&gt;ISO 8601&lt;/a&gt; Date format of YYYY-MM-DD.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastUpdatedDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset LastUpdatedDate { get; set; }

        /// <summary>
        /// Determines the start date of the report - the time component is ignored. For WEEK, MONTH, QUARTER, and YEAR reportPeriods, this value must correspond to the first day in the specified reportPeriod. For example, dataStartTime must be a Sunday for the WEEK reportPeriod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataStartTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset DataStartTime { get; set; }

        /// <summary>
        /// Determines the end date of the report - the time component is ignored. For WEEK, MONTH, QUARTER, and YEAR reportPeriods, this value must correspond to the last day in the specified reportPeriod. For example, dataEndTime must be a Saturday for the WEEK reportPeriod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataEndTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(DateFormatConverter))]
        public System.DateTimeOffset DataEndTime { get; set; }

        /// <summary>
        /// This parameter must match the marketplaceId of the selling partner account (each selling partner account belongs to only one marketplaceId).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("marketplaceIds", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> MarketplaceIds { get; set; } = new System.Collections.ObjectModel.Collection<string>();



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static ReportSpecification FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<ReportSpecification>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public enum ReportSpecificationReportType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GET_VENDOR_INVENTORY_REPORT")]
        GET_VENDOR_INVENTORY_REPORT = 0,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public partial class ReportOptions
    {
        /// <summary>
        /// The distributor view.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("distributorView", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ReportOptionsDistributorView DistributorView { get; set; }

        /// <summary>
        /// Determines what granularity of data is expected in the report. Valid values are: DAY, WEEK, MONTH, QUARTER, YEAR.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportPeriod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ReportOptionsReportPeriod ReportPeriod { get; set; }

        /// <summary>
        /// The selling program.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sellingProgram", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ReportOptionsSellingProgram SellingProgram { get; set; }



        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

        public string ToJson()
        {

            return Newtonsoft.Json.JsonConvert.SerializeObject(this, new Newtonsoft.Json.JsonSerializerSettings());

        }
        public static ReportOptions FromJson(string data)
        {

            return Newtonsoft.Json.JsonConvert.DeserializeObject<ReportOptions>(data, new Newtonsoft.Json.JsonSerializerSettings());

        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public enum ReportOptionsDistributorView
    {

        [System.Runtime.Serialization.EnumMember(Value = @"MANUFACTURING")]
        MANUFACTURING = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"SOURCING")]
        SOURCING = 1,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public enum ReportOptionsReportPeriod
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DAY")]
        DAY = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"WEEK")]
        WEEK = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"MONTH")]
        MONTH = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"QUARTER")]
        QUARTER = 3,


        [System.Runtime.Serialization.EnumMember(Value = @"YEAR")]
        YEAR = 4,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    public enum ReportOptionsSellingProgram
    {

        [System.Runtime.Serialization.EnumMember(Value = @"RETAIL")]
        RETAIL = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"FRESH")]
        FRESH = 1,


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "11.1.0.0 (Newtonsoft.Json v13.0.0.0)")]
    internal class DateFormatConverter : Newtonsoft.Json.Converters.IsoDateTimeConverter
    {
        public DateFormatConverter()
        {
            DateTimeFormat = "yyyy-MM-dd";
        }
    }
}