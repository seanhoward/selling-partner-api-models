/* 
 * The Selling Partner API for Amazon External Fulfillment Shipments Processing
 *
 * You can use the External Fulfillment Shipments API to retrieve, manage, and track shipments processed through Amazon's external fulfillment network. Use this API to get shipment details, monitor status changes, and access fulfillment requirements.
 *
 * OpenAPI spec version: 2024-09-11
 * Contact: marketplaceapitest@amazon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Amazon.SellingPartnerAPIAA.Clients.Models.ExternalFulfillmentShipments
{
    /// <summary>
    /// A shipment&#39;s charge with relevant tax information.
    /// </summary>
    [DataContract]
    public partial class Charge : IEquatable<Charge>, IValidatableObject
    {
        /// <summary>
        /// The type of charge.
        /// </summary>
        /// <value>The type of charge.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ChargeTypeEnum
        {

            /// <summary>
            /// Enum PRODUCT for value: PRODUCT
            /// </summary>
            [EnumMember(Value = "PRODUCT")]
            PRODUCT = 1,

            /// <summary>
            /// Enum SHIPPING for value: SHIPPING
            /// </summary>
            [EnumMember(Value = "SHIPPING")]
            SHIPPING = 2,

            /// <summary>
            /// Enum GIFTWRAP for value: GIFT_WRAP
            /// </summary>
            [EnumMember(Value = "GIFT_WRAP")]
            GIFTWRAP = 3,

            /// <summary>
            /// Enum TOTAL for value: TOTAL
            /// </summary>
            [EnumMember(Value = "TOTAL")]
            TOTAL = 4,

            /// <summary>
            /// Enum OTHER for value: OTHER
            /// </summary>
            [EnumMember(Value = "OTHER")]
            OTHER = 5
        }

        /// <summary>
        /// The type of charge.
        /// </summary>
        /// <value>The type of charge.</value>
        [DataMember(Name = "chargeType", EmitDefaultValue = false)]
        public ChargeTypeEnum ChargeType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Charge" /> class.
        /// </summary>
        [JsonConstructor]
        protected Charge() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Charge" /> class.
        /// </summary>
        /// <param name="baseCharge">The charge value before taxes. (required).</param>
        /// <param name="taxBreakup">The tax charge details..</param>
        /// <param name="chargeType">The type of charge. (required).</param>
        /// <param name="totalCharge">The total charge, including the base charge and taxes. (required).</param>
        /// <param name="totalTax">The sum of all taxes. (required).</param>
        public Charge(ChargeBreakup baseCharge = default, List<Tax> taxBreakup = default, ChargeTypeEnum chargeType = default, ChargeBreakup totalCharge = default, Tax totalTax = default)
        {
            // to ensure "baseCharge" is required (not null)
            if (baseCharge == null)
            {
                throw new InvalidDataException("baseCharge is a required property for Charge and cannot be null");
            }
            else
            {
                this.BaseCharge = baseCharge;
            }
            // to ensure "chargeType" is required (not null)
            if (chargeType == null)
            {
                throw new InvalidDataException("chargeType is a required property for Charge and cannot be null");
            }
            else
            {
                this.ChargeType = chargeType;
            }
            // to ensure "totalCharge" is required (not null)
            if (totalCharge == null)
            {
                throw new InvalidDataException("totalCharge is a required property for Charge and cannot be null");
            }
            else
            {
                this.TotalCharge = totalCharge;
            }
            // to ensure "totalTax" is required (not null)
            if (totalTax == null)
            {
                throw new InvalidDataException("totalTax is a required property for Charge and cannot be null");
            }
            else
            {
                this.TotalTax = totalTax;
            }
            this.TaxBreakup = taxBreakup;
        }

        /// <summary>
        /// The charge value before taxes.
        /// </summary>
        /// <value>The charge value before taxes.</value>
        [DataMember(Name = "baseCharge", EmitDefaultValue = false)]
        public ChargeBreakup BaseCharge { get; set; }

        /// <summary>
        /// The tax charge details.
        /// </summary>
        /// <value>The tax charge details.</value>
        [DataMember(Name = "taxBreakup", EmitDefaultValue = false)]
        public List<Tax> TaxBreakup { get; set; }


        /// <summary>
        /// The total charge, including the base charge and taxes.
        /// </summary>
        /// <value>The total charge, including the base charge and taxes.</value>
        [DataMember(Name = "totalCharge", EmitDefaultValue = false)]
        public ChargeBreakup TotalCharge { get; set; }

        /// <summary>
        /// The sum of all taxes.
        /// </summary>
        /// <value>The sum of all taxes.</value>
        [DataMember(Name = "totalTax", EmitDefaultValue = false)]
        public Tax TotalTax { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Charge {\n");
            sb.Append("  BaseCharge: ").Append(BaseCharge).Append("\n");
            sb.Append("  TaxBreakup: ").Append(TaxBreakup).Append("\n");
            sb.Append("  ChargeType: ").Append(ChargeType).Append("\n");
            sb.Append("  TotalCharge: ").Append(TotalCharge).Append("\n");
            sb.Append("  TotalTax: ").Append(TotalTax).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Charge);
        }

        /// <summary>
        /// Returns true if Charge instances are equal
        /// </summary>
        /// <param name="input">Instance of Charge to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Charge input)
        {
            if (input == null)
                return false;

            return
                (
                    this.BaseCharge == input.BaseCharge ||
                    (this.BaseCharge != null &&
                    this.BaseCharge.Equals(input.BaseCharge))
                ) &&
                (
                    this.TaxBreakup == input.TaxBreakup ||
                    this.TaxBreakup != null &&
                    this.TaxBreakup.SequenceEqual(input.TaxBreakup)
                ) &&
                (
                    this.ChargeType == input.ChargeType ||
                    (this.ChargeType != null &&
                    this.ChargeType.Equals(input.ChargeType))
                ) &&
                (
                    this.TotalCharge == input.TotalCharge ||
                    (this.TotalCharge != null &&
                    this.TotalCharge.Equals(input.TotalCharge))
                ) &&
                (
                    this.TotalTax == input.TotalTax ||
                    (this.TotalTax != null &&
                    this.TotalTax.Equals(input.TotalTax))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.BaseCharge != null)
                    hashCode = hashCode * 59 + this.BaseCharge.GetHashCode();
                if (this.TaxBreakup != null)
                    hashCode = hashCode * 59 + this.TaxBreakup.GetHashCode();
                if (this.ChargeType != null)
                    hashCode = hashCode * 59 + this.ChargeType.GetHashCode();
                if (this.TotalCharge != null)
                    hashCode = hashCode * 59 + this.TotalCharge.GetHashCode();
                if (this.TotalTax != null)
                    hashCode = hashCode * 59 + this.TotalTax.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
